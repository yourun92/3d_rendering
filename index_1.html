<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Четкий 3D SVG</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; width: 100%; height: 100%; }
    </style>
</head>
<body>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/SVGLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Инициализация сцены с улучшенными настройками
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xf0f0f0);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 100);

        // Улучшенный рендерер с настройками антиалиасинга
        const renderer = new THREE.WebGLRenderer({
            antialias: true,
            powerPreference: "high-performance"
        });
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.outputEncoding = THREE.sRGBEncoding;
        document.body.appendChild(renderer.domElement);

        // Усиленное освещение
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight1.position.set(1, 1, 1);
        directionalLight1.castShadow = true;
        scene.add(directionalLight1);

        const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight2.position.set(-1, -0.5, -1);
        scene.add(directionalLight2);

        // Контроллер с улучшенными настройками
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.screenSpacePanning = false;
        controls.maxPolarAngle = Math.PI;

        // Загрузка SVG
        const loader = new THREE.SVGLoader();

        // Вставьте ваш SVG здесь
        const svgString = `svg_file.svg`;

        function createSharp3DModel(svgData) {
            // Улучшенные настройки экструзии
            const extrudeSettings = {
                depth: 20, // Уменьшил глубину для лучшей детализации
                bevelEnabled: true,
                bevelThickness: 1,
                bevelSize: 0.5,
                bevelSegments: 3,
                curveSegments: 24, // Увеличил для гладкости
                steps: 2
            };

            const svgGroup = new THREE.Group();

            // Оптимальный масштаб
            svgGroup.scale.set(0.1, 0.1, 0.1);
            svgGroup.position.set(0, 0, 0);
            svgGroup.rotation.x = Math.PI;

            // Обработка путей с улучшенными материалами
            svgData.paths.forEach(path => {
                const shapes = path.toShapes(true);
                const color = path.userData.style.fill ?
                    new THREE.Color(path.userData.style.fill) :
                    new THREE.Color(0x00aaff);

                shapes.forEach(shape => {
                    const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);

                    // Улучшенный материал
                    const material = new THREE.MeshPhongMaterial({
                        color: color,
                        side: THREE.DoubleSide,
                        specular: 0x111111,
                        shininess: 30,
                        flatShading: false // Для гладких поверхностей
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    svgGroup.add(mesh);
                });
            });

            // Центрирование модели
            const box = new THREE.Box3().setFromObject(svgGroup);
            const center = box.getCenter(new THREE.Vector3());
            svgGroup.position.sub(center);

            scene.add(svgGroup);

            // Автоматическое приближение камеры
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const cameraZ = Math.abs(maxDim / Math.sin(fov / 2));
            camera.position.z = cameraZ * 1.5;
            controls.update();
        }

        try {
            const svgData = loader.parse(svgString);
            createSharp3DModel(svgData);
        } catch (e) {
            console.error("SVG Error:", e);
            document.body.innerHTML = '<div style="padding:20px;color:red">Ошибка обработки SVG. Проверьте консоль.</div>';
        }

        // Анимация
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // Адаптивный ресайз
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>